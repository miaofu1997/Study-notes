# 1.5 Currying, Implicit Conversions, Generic Classes

## 柯里化与隐式转换

{% tabs %}
{% tab title="柯里化方法" %}
```scala
object ImplicitValueDemo1 {

  //柯里化方法，y有默认值，【普通】的默认值不能使用
  // val r = kl1(20)会报错
  def kl1(x: Int)(y: Int = 8): Int = {
    x + y
  }

  //柯里化方法结合隐式值，才可以正常使用
  // val r = kl2(20)不报错 返回28
  def kl2(x: Int)(implicit y: Int = 8): Int = {
    x + y
  }

  def main(args: Array[String]): Unit = {

    val r1 = kl2(20)
    println(r4)
    
  }
}
```
{% endtab %}

{% tab title="普通方法" %}
```scala
object ImplicitValueDemo2 {

  def m1(x: Int): Int = {
    x * x
  }

  //普通的方法，传递普通的参数，可以使用默认值，不用定义成implicit参数
  def m2(x: Int = 8): Int = {
    x * x
  }
  
  //普通的方法，也可以定义成implicit，不会报错
  def m3(implicit x: Int = 8): Int = {
    x * x
  }

  def main(args: Array[String]): Unit = {
    val r1 = m1(8)
    println(r1)

    //方法中的参数有默认值 可以不传参 返回64
    val r2 = m2()
    println(r2)

    //外部传了值会优先使用 返回100
    val r3 = m2(10)
    println(r3)

    val r4 = m3()
    println(r5)
  }
}
```
{% endtab %}
{% endtabs %}

### 柯里化结合隐式转换传参

Scala的柯里化结合隐式参数，程序中若有用`implicit`修饰的参数，程序执行时会到程序的执行环境（Context） 找**用`implicit`修饰的、参数类型一致**参数，有就传递过来使用，并不需要变量名一致。

如果传递参数，优先使用传递的参数，如果有`implicit`修饰的类型一致的参数，用该隐式值，如果还没有，则再用默认值。

```text

```



