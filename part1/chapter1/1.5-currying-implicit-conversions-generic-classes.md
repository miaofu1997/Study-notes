---
description: 'Currying, Implicit Conversions and Generic Classes'
---

# 1.5 Implicit Conversions, Generic Classes

## ✨ 柯里化与隐式转换

### 柯里化

方法可以定义多个参数列表（即方法名后跟多个括号如下\#line5和\#line9），当使用较少的参数列表调用多参数列表的方法时，会产生一个新的**函数**，该函数接收剩余的参数列表作为其参数。这被称为柯里化。

```scala
object KlDemo {

  //柯里化
  //定义一个方法，可以有多个括号传递参数
  def kl(x: Int)(y: Int): Int = {
    x + y
  }

  def kl2(x: Int)(y: Int, z: Int): Int = {
    x + y + z
  }


  def main(args: Array[String]): Unit = {

    val r1 = kl(5)(6)
    println(r1)

    val f = kl(8) _ //柯里化方法 只传一个值x=8
    println(f)
    //f的类型为<function1>

    val r1 = f(7)
    println(r1)
    //f(7)表示在x=8的基础上传入y=7返回15

    val f2 = kl2(8) _
    println(f2)
    //f2的类型为<function2> 接受(y: Int, z: Int)作为f2的参数

  }
}
```

### 隐式参数

柯里化方法定义默认值必须用`implicit`关键字，否则会报错。

{% tabs %}
{% tab title="柯里化方法 默认值" %}
```scala
object ImplicitValueDemo1 {

  //柯里化方法，y有默认值，【普通】的默认值不能使用
  // val r = kl1(20)会报错
  def kl1(x: Int)(y: Int = 8): Int = {
    x + y
  }

  //柯里化方法结合隐式值，才可以正常使用
  // val r = kl2(20)不报错 返回28
  def kl2(x: Int)(implicit y: Int = 8): Int = {
    x + y
  }

  def main(args: Array[String]): Unit = {
  
    //第二个y没有传入参数 用默认值
    val r1 = kl2(20)
    println(r4)
    
  }
}
```
{% endtab %}

{% tab title="普通方法 默认值" %}
```scala
object ImplicitValueDemo2 {

  def m1(x: Int): Int = {
    x * x
  }

  //普通的方法，传递普通的参数，可以使用默认值，不用定义成implicit参数
  def m2(x: Int = 8): Int = {
    x * x
  }
  
  //普通的方法，也可以定义成implicit，不会报错
  def m3(implicit x: Int = 8): Int = {
    x * x
  }

  def main(args: Array[String]): Unit = {
    val r1 = m1(8)
    println(r1)

    //方法中的参数有默认值 可以不传参 返回64
    val r2 = m2()
    println(r2)

    //外部传了值会优先使用 返回100
    val r3 = m2(10)
    println(r3)

    val r4 = m3()
    println(r5)
  }
}
```
{% endtab %}
{% endtabs %}

### 柯里化结合隐式转换传参

Scala的柯里化结合隐式参数，程序中若有用`implicit`修饰的参数，程序执行时会到程序的执行环境（Context） 找**用`implicit`修饰的、参数类型一致**参数，有就传递过来使用，并不需要变量名一致。

如果传递参数，优先使用传递的参数；若没传参，但有`implicit`修饰的类型一致的参数，用该隐式值；如果还没有，则再用默认值。

隐式值可以不定义在内部，从外部类、外部object引入也可以。

{% tabs %}
{% tab title="内部定义隐式值" %}
```scala
object ImplicitValueDemo3 {
  //定义隐式值
  implicit val abc = 666

  //柯里化方法结合隐式值
  def kl2(x: Int)(implicit y: Int = 8): Int = {
    x + y
  }

  def main(args: Array[String]): Unit = {

    //返回20+666=686
    val r4 = kl2(20)
    println(r4)

  }
}
```
{% endtab %}

{% tab title="通过object、class中导入隐式值" %}
```scala
object ImplicitValueDemo4 {

  //柯里化方法结合隐式值
  def kl2(x: Int)(implicit y: Int = 8): Int = {
    x + y
  }

  def main(args: Array[String]): Unit = {

    //从object导入隐式参数
    import MyContext._

    //如果是类，先要new实例，然后再导入隐式值
    val mc = new MyContext2
    import mc.abcdef
    
    //以上从object或class中导入隐式值只能二选一，返回7797或5575
    val r4 = kl2(20)
    println(r4)

  }
}
```
{% endtab %}

{% tab title="object" %}
{% code title="MyContext.scala" %}
```scala
object MyContext {
  implicit val abcd: Int = 7777
}
```
{% endcode %}
{% endtab %}

{% tab title="class" %}
{% code title="MyContext2.scala" %}
```scala
class MyContext2 {
  implicit val abcdef: Int = 5555
}
```
{% endcode %}
{% endtab %}
{% endtabs %}

在程序中，如果有多个用`implicit`修饰的类型一致的隐式值，则会出错。

