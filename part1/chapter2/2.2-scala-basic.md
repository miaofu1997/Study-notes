# 2.2 Scala Basics

## Scala概述

### 什么是Scala

Scala是一种多范式的编程语言，其设计的初衷是要集成面向对象编程和函数式编程的各种特性。Scala运行于Java平台（Java虚拟机），并兼容现有的Java程序。

![2](../../.gitbook/assets/0.jpeg)

### 为什么要学Scala

1. 优雅：这是框架设计师第一个要考虑的问题，框架的用户是应用开发程序员，API是否优雅直接影响用户体验。
2. 速度快：Scala语言表达能力强，一行代码抵得上Java多行，开发速度快；Scala是静态编译的，所以和JRuby,Groovy比起来速度会快很多。
3.  能融合到Hadoop生态圈：Hadoop现在是大数据事实标准，Spark并不是要取代Hadoop，而是要完善Hadoop生态。JVM语言大部分可能会想到Java，但Java做出来的API太丑，或者想实现一个优雅的API太费劲。 

![comparison](../../.gitbook/assets/1.png)

## Scala编译器安装

### 安装JDK

因为Scala是运行在JVM平台上的，所以安装Scala之前要安装JDK

### 安装Scala

#### Windows安装Scala编译器

访问Scala官网http://www.scala-lang.org/下载Scala编译器安装包，目前最新版本是2.12.x，但是目前大多数的框架都是用2.11.x编写开发的，Spark 2.x使用的就是2.11.x，所以这里推荐2.11.x版本，下载Scala-2.11.8.msi后点击下一步

#### Linux安装Scala编译器

下载Scala地址http://downloads.typesafe.com/scala/2.11.8/scala-2.11.8.tgz然后解压Scala到指定目录

`tar -zxvf scala-2.11.8.tgz -C /usr/java`

配置环境变量，将Scala加入到PATH中

`vi /etc/profile`

`export JAVA_HOME=/usr/java/jdk1.8.0_111`

`export PATH=$PATH:$JAVA_HOME/bin:/usr/java/scala-2.11.8/bin`

#### Scala开发工具安装

目前Scala的开发工具主要有两种：Eclipse和IDEA，这两个开发工具都有相应的Scala插件，如果使用Eclipse，直接到Scala官网下载即可http://scala-ide.org/download/sdk.html。

由于IDEA的Scala插件更优秀，大多数Scala程序员都选择IDEA，可以到http://www.jetbrains.com/idea/download/下载社区免费版，点击下一步安装即可，安装时如果有网络可以选择在线安装Scala插件。这里我们使用离线安装Scala插件：

1. 安装IDEA，点击下一步即可。由于我们离线安装插件，所以点击Skip All and Set Default
2. 下载IEDA的Scala插件，地址http://plugins.jetbrains.com/?idea\_ce
3. 安装Scala插件：Configure -&gt; Plugins -&gt; Install plugin from disk -&gt; 选择Scala插件 -&gt; OK -&gt; 重启IDEA

![0](../../.gitbook/assets/2.jpeg)

![1](../../.gitbook/assets/3.jpeg)

![3](../../.gitbook/assets/4.jpeg)

![5](../../.gitbook/assets/5.jpeg)

## Scala基础

### 声明变量

```scala
object VariableTest {
 def main(args: Array[String]) {
 //使用val定义的变量值是不可变的，相当于java里用final修饰的变量
 val i = 1
 //使用var定义的变量是可变得，在Scala中鼓励使用val
 var s = "hello"
 //Scala编译器会自动推断变量的类型，必要的时候可以指定类型
 //变量名在前，类型在后
 val str: String = "world"
 }
}
```

### 常用类型

Scala和Java一样，有7种数值类型：

Byte、Char、Short、Int、Long、Float和Double（无包装类型）和一个Boolean类型

### 条件表达式

Scala的的条件表达式比较简洁，例如：

```scala
object ConditionTest {
 def main(args: Array[String]) {
 val x = 1
 //判断x的值，将结果赋给y
 val y = if (x > 0) 1 else -1
 //打印y的值
 println(y)
 //支持混合类型表达式
 val z = if (x > 1) 1 else "error"
 //打印z的值//类似是Any，相当与是Int和String的父类型
 println(z)
 //如果缺失else，相当于if (x > 2) 1 else ()
 val m = if (x > 2) 1
 println(m)
 //在scala中每个表达式都有值，scala中有个Unit类，写做(),相当于Java中的void
 val n = if (x > 2) 1 else ()
 println(n)
 //if和else if
 val k = if (x < 0) 0
 else if (x >= 1) 1 else -1
 println(k)
 }
}
```

### 块表达式

```scala
object BlockExpressionTest {
 def main(args: Array[String]) {
 val x = 0
 //在scala中{}中课包含一系列表达式，块中最后一个表达式的值就是块的值
 //下面就是一个块表达式
 val result = {
 if (x < 0){
 -1
 } else if(x >= 1) {
 1
 } else {
 "error"
 }
 }
 //result的值就是块表达式的结果
 println(result)
 }
}
```

### 循环

在scala中有for循环和while循环，用for循环比较多

for循环语法结构：**for** \(i &lt;- 表达式/数组/集合\)

  
__**object** ForTest {  
 **def** main\(args: Array\[String\]\) {  
 _//for\(i &lt;- 表达式\),表达式1 to 10返回一个Range（区间）_

 _//每次循环将区间中的一个值赋给i_  
 **for** \(i &lt;- 1 to 10\)  
 _println_\(i\)

 _//for\(i &lt;- 数组\)_  
 **val** arr = _Array_\(**"a"**, **"b"**, **"c"**\)  
 **for** \(i &lt;- arr\)  
 _println_\(i\)

 _//高级for循环  
 //每个生成器都可以带一个条件，注意：if前面没有分号_  
 **for**\(i &lt;- 1 to 3; j &lt;- 1 to 3 **if** i != j\)  
 _print_\(\(10 \* i + j\) + **" "**\)  
 _println_\(\)

 _//for推导式：如果for循环的循环体以yield开始，则该循环会构建出一个集合_

 _//每次迭代生成集合中的一个值_  
 **val** v = **for** \(i &lt;- 1 to 10\) **yield** i \* 10  
 _println_\(v\)

 }

}

### 调用方法

Scala中的+ - \* / %等操作符的作用与Java一样，位操作符 & \| ^ &gt;&gt; &lt;&lt;也一样。只是有

一点特别的：这些操作符实际上是方法。例如：

a + b

是如下方法调用的简写：

1. +\(b\)

a 方法 b可以写成 a.方法\(b\)

### 定义方法

#### 定义方法

![QQ&#x622A;&#x56FE;20151201161545](../../.gitbook/assets/6.png)

方法的返回值类型可以不写，编译器可以自动推断出来，但是对于递归方法，必须指定返回类型

## 数组、映射、元组、集合

### 数组

#### 定长数组和变长数组

**import** scala.collection.mutable.ArrayBuffer

  
__**object** ArrayTest {

 **def** main\(args: Array\[String\]\) {

 _//初始化一个长度为8的定长数组，其所有元素均为0_  
 **val** arr1 = **new** Array\[Int\]\(8\)  
 _//直接打印定长数组，内容为数组的hashcode值  
 println_\(arr1\)  
 _//将数组转换成数组缓冲，就可以看到原数组中的内容了  
 //toBuffer会将数组转换长数组缓冲  
 println_\(arr1.toBuffer\)

 _//注意：如果new，相当于调用了数组的apply方法，直接为数组赋值  
 //初始化一个长度为1的定长数组_  
 **val** arr2 = _Array_\[Int\]\(10\)  
 _println_\(arr2.toBuffer\)

 _//定义一个长度为3的定长数组_  
 **val** arr3 = _Array_\(**"hadoop"**, **"storm"**, **"spark"**\)  
 _//使用\(\)来访问元素  
 println_\(arr3\(2\)\)

 _//////////////////////////////////////////////////  
 //变长数组（数组缓冲）  
 //如果想使用数组缓冲，需要导入import scala.collection.mutable.ArrayBuffer包_  
 **val** ab = ArrayBuffer\[Int\]\(\)  
 _//向数组缓冲的尾部追加一个元素  
 //+=尾部追加元素_  
 ab += 1  
 _//追加多个元素_  
 ab += \(2, 3, 4, 5\)  
 _//追加一个数组++=_  
 ab ++= _Array_\(6, 7\)  
 _//追加一个数组缓冲_  
 ab ++= ArrayBuffer\(8,9\)  
 _//打印数组缓冲ab_

 _//在数组某个位置插入元素用insert_ab.insert\(0, -1, 0\)  
 _//删除数组某个位置的元素用remove_  
 ab.remove\(8, 2\)  
 _println_\(ab\)

 }  
}

#### 遍历数组

1.增强for循环

2.好用的until会生成脚标，0 until 10 包含0不包含10

![QQ&#x622A;&#x56FE;20151202095702](../../.gitbook/assets/7.png)

**object** ForArrayTest {

 **def** main\(args: Array\[String\]\) {  
 _//初始化一个数组_  
 **val** arr = _Array_\(1,2,3,4,5,6,7,8\)  
 _//增强for循环_  
 **for**\(i &lt;- arr\)  
 _println_\(i\)

 _//好用的until会生成一个Range  
 //reverse是将前面生成的Range反转_  
 **for**\(i &lt;- \(0 until arr.length\).reverse\)  
 _println_\(arr\(i\)\)  
 }  
}

#### 数组常用算法

在Scala中，数组上的某些方法对数组进行相应的操作非常方便！

![QQ&#x622A;&#x56FE;20151202115822](../../.gitbook/assets/8.png)

### 映射

在Scala中，把哈希表这种数据结构叫做映射

#### 构建映射

![QQ&#x622A;&#x56FE;20151202152932](../../.gitbook/assets/9.png)

#### 获取和修改映射中的值

![QQ&#x622A;&#x56FE;20151202153219](../../.gitbook/assets/10.png)

好用的getOrElse

![QQ&#x622A;&#x56FE;20151202150344](../../.gitbook/assets/11.png)

注意：在Scala中，有两种Map，一个是immutable包下的Map，该Map中的内容不可变；另一个是mutable包下的Map，该Map中的内容可变

例子：

![QQ&#x622A;&#x56FE;20151202152100](../../.gitbook/assets/12.png)

注意：通常我们在创建一个集合是会用val这个关键字修饰一个变量（相当于java中的final），那么就意味着该变量的引用不可变，该引用中的内容是不是可变，取决于这个引用指向的集合的类型

### 元组

映射是K/V对偶的集合，对偶是元组的最简单形式，元组可以装着多个不同类型的值。

#### 创建元组

![QQ&#x622A;&#x56FE;20151202154418](../../.gitbook/assets/13.png)

#### 获取元组中的值

![QQ&#x622A;&#x56FE;20151202155158](../../.gitbook/assets/14.png)

#### 将对偶的集合转换成映射

![QQ&#x622A;&#x56FE;20151202161441](../../.gitbook/assets/15.png)

#### 拉链操作

**zip**命令可以将多个值绑定在一起

![QQ&#x622A;&#x56FE;20151202162144](../../.gitbook/assets/16.png)

注意：如果两个数组的元素个数不一致，拉链操作后生成的数组的长度为较小的那个数组的元素个数

### 集合

Scala的集合有三大类：序列Seq、集Set、映射Map，所有的集合都扩展自Iterable特质

在Scala中集合有可变（mutable）和不可变（immutable）两种类型，immutable类型的集合初始化后就不能改变了（注意与val修饰的变量进行区别）

#### 序列

不可变的序列 import scala.collection.immutable.\_

在Scala中列表要么为空（Nil表示空列表）要么是一个head元素加上一个tail列表。

9 :: List\(5, 2\) :: 操作符是将给定的头和尾创建一个新的列表

注意：:: 操作符是右结合的，如9 :: 5 :: 2 :: Nil相当于 9 :: \(5 :: \(2 :: Nil\)\)

**object** ImmutListTest {

 **def** main\(args: Array\[String\]\) {  
 _//创建一个不可变的集合_  
 **val** lst1 = _List_\(1,2,3\)  
 _//将0插入到lst1的前面生成一个新的List_  
 **val** lst2 = 0 :: lst1  
 **val** lst3 = lst1.::\(0\)  
 **val** lst4 = 0 +: lst1  
 **val** lst5 = lst1.+:\(0\)

 _//将一个元素添加到lst1的后面产生一个新的集合_  
 **val** lst6 = lst1 :+ 3

 **val** lst0 = _List_\(4,5,6\)  
 _//将2个list合并成一个新的List_  
 **val** lst7 = lst1 ++ lst0  
 _//将lst0插入到lst1前面生成一个新的集合_  
 **val** lst8 = lst1 ++: lst0

 _//将lst0插入到lst1前面生成一个新的集合_  
 **val** lst9 = lst1.:::\(lst0\)

 _println_\(lst9\)  
 }  
}

可变的序列 import scala.collection.mutable.\_

**import** scala.collection.mutable.ListBuffer

**object** MutListTest **extends** App{  
 _//构建一个可变列表，初始有3个元素1,2,3_  
 **val** _lst0_ = ListBuffer\[Int\]\(1,2,3\)  
 _//创建一个空的可变列表_  
 **val** _lst1_ = **new** ListBuffer\[Int\]  
 _//向lst1中追加元素，注意：没有生成新的集合  
 lst1_ += 4  
 _lst1_.append\(5\)

 _//将lst1中的元素最近到lst0中， 注意：没有生成新的集合  
 lst0_ ++= _lst1_

 _//将lst0和lst1合并成一个新的ListBuffer 注意：生成了一个集合_**val** _lst2_= _lst0_ ++ _lst1_

 _//将元素追加到lst0的后面生成一个新的集合_**val** _lst3_ = _lst0_ :+ 5  
}

### Set

不可变的Set

**import** scala.collection.immutable.HashSet

**object** ImmutSetTest **extends** App{  
 **val** _set1_ = **new** HashSet\[Int\]\(\)  
 _//将元素和set1合并生成一个新的set，原有set不变_  
 **val** _set2_ = _set1_ + 4  
 _//set中元素不能重复_  
 **val** _set3_ = _set1_ ++ _Set_\(5, 6, 7\)  
 **val** _set0_ = _Set_\(1,3,4\) ++ _set1  
 println_\(_set0_.getClass\)  
}

可变的Set

**import** scala.collection.mutable

**object** MutSetTest **extends** App{  
 _//创建一个可变的HashSet_  
 **val** _set1_ = **new** mutable.HashSet\[Int\]\(\)  
 _//向HashSet中添加元素  
 set1_ += 2  
 _//add等价于+=  
 set1_.add\(4\)  
 _set1_ ++= _Set_\(1,3,5\)  
 _println_\(_set1_\)  
 _//删除一个元素  
 set1_ -= 5  
 _set1_.remove\(2\)  
 _println_\(_set1_\)  
}

### Map

**import** scala.collection.mutable

**object** MutMapTest **extends** App{  
 **val** _map1_ = **new** mutable.HashMap\[String, Int\]\(\)  
 _//向map中添加数据  
 map1_\(**"spark"**\) = 1  
 _map1_ += \(\(**"hadoop"**, 2\)\)  
 _map1_.put\(**"storm"**, 3\)  
 _println_\(_map1_\)

 _//从map中移除元素  
 map1_ -= **"spark"**  
 _map1_.remove\(**"hadoop"**\)  
 _println_\(_map1_\)  
}

