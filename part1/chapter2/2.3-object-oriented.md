---
description: 类、对象、继承、特质
---

# 2.3 Object Oriented

## ✨ 类

Scala的类与Java、C++的类比起来，更简洁。

### 类的定义

在Scala中，类并不用声明为`public`，默认是public。一个Scala源文件中可以包含**多个类**，所有这些类都具有公有可见性。初始化时可以给定某特殊的默认值，也可以通过下划线方式设置为该类型的系统默认值，但此时必须声明变量的类型。

```scala
  var name: String = _
  var age: Int = _
  var faceValue: Double = _
```

### 类的伴生对象

在Scala的类中，与类名相同的对象叫做伴生对象，类和伴生对象之间可以相互访问私有的方法和属性。要求：

* 用Object定义，object名字与类名一致
* object与class在同一个.scala文件中

```scala
class User {
  val name = "Tom"
  //pet是私有的成员变量 不能用u.pet访问了
  private var pet: String = "小强"
}


//伴生对象
object User{
  def main(args: Array[String]): Unit = {
    val u = new User
    println(u.name)
    //在这里可以获取private修饰的变量pet
    println(u.pet)
  }
}
```

### 类的权限控制

* Scala中`private`修饰的变量或者方法，在其他类/Object中无法访问，只能在类的内部或伴生对象访问。
* Scala中`private[this]`修饰的变量或者方法，在其他类/Object/伴生对象中**都**中无法访问，只能在类的内部访问。
* `private`和`private[this]`同样可以修饰类，`private[包名] class User {...}`。表示只能在包及其子包中访问。
* 类和伴生对象可以相互访问`private`修饰的变量和方法。
* `private[this]`如果在类/object中定义，就只能在类/object的内容使用。
* 用`protected`，子类也可以访问。

```scala
class Student {
 //用val修饰的变量是只读属性，相当于有getter但没有setter
 //相当与Java中用final修饰的变量
 val id = 666

 //用var修饰的变量既有getter又有setter
 var age: Int = 20
 
 //类私有字段,只能在类的内部使用,和伴生对象中使用
 private var name: String = "tom"

 //对象私有字段,访问权限更加严格的，只能在类的内部【当前实例中使用】
 private[this] val pet = "小强"
 
}
```

### 构造器

每个类都有主构造器，起到new这个类的实例的时候帮助传递一些参数，初始化的作用。主构造器的参数直接放置类名后面，与类交织在一起。用`val`或`var`修饰，构造器参数会成为这个类的成员变量。也可以加`private`或`private[this]`修饰。除了主构造器还可以用辅助构造器来补充。

主构造器会执行类定义中的所有语句。比如打印、加载函数、简单运算、访问数据库等。在new对象的时候就执行。

```scala
class Person(val name: String, val age: Int){
 
 //主构造器会执行类定义中的所有语句
 println("执行主构造器")
 
 try {
 println("读取文件")
 throw new IOException("io exception")
 } catch {
 case e: NullPointerException => println("打印异常Exception : " + e)
 case e: IOException => println("打印异常Exception : " + e)
 } finally {
 println("执行finally部分")
 }
 
 private var gender = "male"
 
 //用this关键字定义辅助构造器，是参数比较多的，是对主构造器的扩展
 def this(name: String, age: Int, gender: String){
 //每个辅助构造器必须以主构造器或其他的辅助构造器的调用为第一行开始
 this(name, age)
 println("执行辅助构造器")
 this.gender = gender
 }
}


//在类名后面加private构造器就变成了私有的，只有在其伴生对象中可以new类的实例
class People private(val name: String, private var age: Int = 18){
}

object People{
 def main(args: Array[String]) {
 //私有的构造器，
 val q = new People("hatano", 20)
 }
}
```



## ✨ 对象

要和Java里的“对象”作区分，Java里的“对象”就是通过一个类new出来的一个实例（instance）。Scala里面的object则是指静态对象（单例对象）。单例对象指它在整个进程中只有一个实例对象。伴生对象一定是静态的、单例的。

### 单例对象

在Scala中没有静态方法和静态字段，但是可以使用object这个语法结构来达到同样的目的。

* 存放工具方法和常量
* 高效共享单个不可变的实例
* 单例模式

```scala
import scala.collection.mutable.ArrayBuffer

object SingletonDemo {
   def main(args: Array[String]) {
    //单例对象，不需要new，用【类名.方法】调用对象中的方法
    val session1 = SessionFactory.getSession()
    println(SessionFactory) //两种方式一样
    println(session1)
    val session2 = SessionFactory.getSession()
    val sf = SessionFactory
    println(sf) //两种方式一样
    println(session2)
  }
}
}

object SessionFactory{ //进行会话的对象，只需要一个这样都“工厂”生产出session就可以了
 //该部分相当于java中的静态块
 var counts = 5
 val sessions = new ArrayBuffer[Session]()
 while(counts > 0){
  sessions += new Session
  counts -= 1
 }
 
 //在object中的方法相当于java中的静态方法
 def getSession(): Session ={
  sessions.remove(0)
 }
}

class Session{ //以后要生产多个实例。

}
```

**注意**：_Session是通过类new出来的\(line\#14\)多个实例，所以session1和session2打印地址不一样。而SessionFactory是单例对象，所以两次打印地址一样。代码\(line\#17-24\)在类加载的时候\(line\#10\)就执行。_

### apply方法

通常会在**类的伴生对象**中定义apply方法，当遇到`类名(参数1,...参数n)`时apply方法会被调用**。**

```scala
object ApplyDemo {

  //静态对象可以有多个apply方法 但参数不能相同 即apply方法可以重载
  def apply() = {
    println("888")
  }
  def apply(x: Int) = {
    println(x)
  }
  def apply(x: Int, y: Double) = {
    println(x+y)
  }


  def main(args: Array[String]): Unit = {
    ApplyDemo()
    ApplyDemo.apply()
    //以上二者等价，Scala只允许apply方法不写".apply()"
    //直接"静态对象名(参数)"就调用对应对象的apply方法

    ApplyDemo(666)

    ApplyDemo(2,9.5)

    val arr1 = Array(1,2,3,4,5) //Array是对象 这里就用了apply方法省略
    val arr2 = Array.apply(1,2,3,4,5) //二者等价
  }
}

```

### 应用程序对象

Scala程序都必须从一个对象的main方法开始，可以通过扩展App特质，不写main方法。

```scala
object AppObjectDemo extends App{
 //不用写main方法 也可以运行 App里有了main
 println("I love you Scala")
}

```



## ✨ 继承

### 扩展类

在Scala中扩展类的方式和Java一样都是使用`extends`关键字。**第一次**无论是继承类还是实现特质，都使用extends关键字，后面如果还有多个特质再用`with`。Scala里只能`extends`一个类，但是可以`with`多个trait。

### 重写方法

在Scala中重写一个非抽象的方法（有实现的）必须使用`override`修饰符。

_相关练习代码：`day02包里的Animal, Dog, Pig, Monkey, Flyable, Fightable几个文件`_

### 多态

实现多态的两个要求：

* 父类引用指向子类对象（接口指向实现类）
* 方法的重写

{% tabs %}
{% tab title="Animal" %}
```scala
abstract class Animal {

  def run(): Unit = {
    println("run")
  }

  def breath() ={
    println("呼吸氧气")
  }

}
```
{% endtab %}

{% tab title="Monkey" %}
```scala
class Monkey extends Animal with Flyable with Fightable {

  override def run(): Unit = {
    println("蹦蹦跳跳的走")
  }

  override def fly(): Unit = {
    println("乘筋斗云飞")
  }

  //重写那些已经有实现的方法，就一定要用override关键字
  override def fight(): Unit = {
    println("使用金箍棒打")
  }
}

object Monkey {

  def main(args: Array[String]): Unit = {
    val m = new Monkey
    m.run()
    m.breath()
    m.fly()
    m.fight()

    //多态：父类引用指向子类对象（接口指向实现类）；方法的重写
    val a: Animal = new Monkey
    a.run()
  }

}
```
{% endtab %}

{% tab title="Dog" %}
```scala
class Dog extends Fightable {

  override def fight(): Unit = {
    println("咬你")
  }
}

object Dog {
  def main(args: Array[String]): Unit = {

    //可以在new对象的时候动态实现接口 新增功能
    val d = new Dog with Flyable {
      override def fly(): Unit = {
        println("狗也会飞！")
      }
    }
    
    d.fight()
    d.fly()

  }
}
```
{% endtab %}
{% endtabs %}

### 

## ✨ 函数

函数的本质就是一个引用。要定义一个变量来引用它，否则为匿名类型，只能用一次。定义函数的结构为 \(参数列表\) =&gt; { 函数体 }，如`val f = (x: Int, y: Double) => { x + y }`

完整的写法：`val f2:`**`(Int, Double) => (Double, Int)`** `= { (x, y) => (y, x) }`，加粗部分声明函数的类型，后面的`(x, y)` 就可以不再写类型了。

同样，`val f3 = (x: Int) => x * x`与`val f3:` **`Int`** `= { x =>  x * x }`一样。

### 函数与方法的区别

函数可以作为参数传入到方法里面，可以灵活的传入运算逻辑。

* 方法：“你要干什么”
* 函数：“你具体要怎么干”

{% tabs %}
{% tab title="给每个元素平方" %}
```scala
val lst = List(1,2,3,4,5,6,7)

val f1 = (x: Int) => x * 10
lst.map(f1)
//输出为 List(10, 20, 30, 40, 50, 60, 70)

val f2 = (x: Int) => x * x
lst.map(f2)
//输出为 List(1, 4, 9, 16, 25, 36, 49)

//也可以直接传匿名函数
lst.map((x: Int) => x * x)

//类型也可以不用写
lst.map(x => x * x)
```
{% endtab %}

{% tab title="过滤出偶数乘以10" %}
```scala
val lst = List(1,2,3,4,5,6,7,8,9,10)

//把偶数过滤出来做映射乘以10
for(e <- lst if e % 2 == 0) yield e * 10
//输出为 List(20, 40, 60, 80, 100)

val f1 = (x: Int) => x % 2 == 0

lst.filter(f1).map(x => x * 10) //链式编程
```
{% endtab %}
{% endtabs %}

### 函数式编程实现Word Count

```scala
val lines = List("hello tom hello jerry","hello tom jerry","hello hello tom")

lines.map(x => x.split(" ")).flatten
//和for(line <- lines) yield line.split(" ")等价
//flatten 压平 把大List里面的小集合Array去掉了 仍有序
//得到List(hello, tom, hello, jerry, hello, tom, jerry, hello, hello, tom)

val words = lines.flatMap(x => x.split(" ")) //和上面等价

val wordAndOne = words.map(x => (x,1))
//得到List((hello,1), (tom,1), (hello,1), (jerry,1), (hello,1), (tom,1), (jerry,1), (hello,1), (hello,1), (tom,1))

val grouped = wordAndOne.groupBy(t => t._1)
//得到Map[String,List[(String, Int)]] = Map(tom -> List((tom,1), (tom,1), (tom,1)), jerry -> List((jerry,1), (jerry,1)), hello -> List((hello,1), (hello,1), (hello,1), (hello,1), (hello,1)))
//装的对偶元组 现在想遍历出来

grouped.map(t => (t._1,t._2.size))
//得到Map(tom -> 3, jerry -> 2, hello -> 5)

grouped.map(t => (t._1,t._2.size)).toList.sortBy(t => -t._2)
//得到List((hello,5), (tom,3), (jerry,2))
```











#### 类型检查和转换

| **Scala** | **Java** |
| :--- | :--- |
| obj.isInstanceOf\[C\] | obj instanceof C |
| obj.asInstanceOf\[C\] | \(C\)obj |
| classOf\[C\] | C.class |

#### 超类的构造

**object** ClazzDemo {  
 **def** main\(args: Array\[String\]\) {  
  
__ }  
}

**trait** Flyable{  
 **def** fly\(\): Unit ={  
 _println_\(**"I can fly"**\)  
 }

 **def** fight\(\): String  
}

**abstract class** Animal {  
 **def** run\(\): Int  
 **val** name: String  
}

**class** Human **extends** Animal **with** Flyable{

 **val** _name_ = **"abc"**_//打印几次"ABC"?_  
 **val** _t1_,_t2_,\(_a_, _b_, _c_\) = {  
 _println_\(**"ABC"**\)  
 \(1,2,3\)  
 }

 _println_\(_a_\)  
 _println_\(_t1_.\_1\)

 _//在Scala中重写一个非抽象方法必须用override修饰_  
 **override def** fight\(\): String = {  
 **"fight"**  
 }  
 _//在子类中重写超类的抽象方法时，不需要使用override关键字，写了也可以_  
 **def** run\(\): Int = {  
 1  
 }  
}

## 模式匹配和样例类

Scala有一个十分强大的模式匹配机制，可以应用到很多场合：如switch语句、类型检查等。

并且Scala还提供了样例类，对模式匹配进行了优化，可以快速进行匹配

### 匹配字符串

```scala
import scala.util.Random

object CaseDemo01 extends App{
 val arr = Array("YoshizawaAkiho", "YuiHatano", "AoiSola")
 val name = arr(Random.nextInt(arr.length))
 name match {
 case "YoshizawaAkiho" => println("吉泽老师...")
 case "YuiHatano" => println("波多老师...")
 case _ => println("真不知道你们在说什么...")
 }
}
```

### **匹配类型**

**import** scala.util.Random  
  
__**object** CaseDemo01 **extends** App{  
 _//val v = if\(x &gt;= 5\) 1 else if\(x &lt; 2\) 2.0 else "hello"_  
 **val** _arr_ = _Array_\(**"hello"**, 1, 2.0, CaseDemo\)  
 **val** _v_ = _arr_\(Random.nextInt\(4\)\)  
 _println_\(_v_\)  
 _v_ **match** {  
 **case** x: Int =&gt; _println_\(**"Int "** + x\)  
 **case** y: Double **if**\(y &gt;= 0\) =&gt; _println_\(**"Double "**+ y\)  
 **case** z: String =&gt; _println_\(**"String "** + z\)  
 **case** \_ =&gt; **throw new** Exception\(**"not match exception"**\)  
 }  
}

**注意：**case y: Double if\(y &gt;= 0\) =&gt; ...

模式匹配的时候还可以添加守卫条件。如不符合守卫条件，将掉入case \_中

### 匹配数组、元组

**object** CaseDemo03 **extends** App{

 **val** _arr_ = _Array_\(1, 3, 5\)  
 _arr_ **match** {  
 **case** _Array_\(1, x, y\) =&gt; _println_\(x + **" "** + y\)  
 **case** _Array_\(0\) =&gt; _println_\(**"only 0"**\)  
 **case** _Array_\(0, \_\*\) =&gt; _println_\(**"0 ..."**\)  
 **case** \_ =&gt; _println_\(**"something else"**\)  
 }

 **val** _lst_ = _List_\(3, -1\)  
 _lst_ **match** {  
 **case** 0 _:: Nil_ =&gt; _println_\(**"only 0"**\)  
 **case** x _::_ y _:: Nil_ =&gt; _println_\(**s"x: $**x **y: $**y**"**\)  
 **case** 0 _::_ tail =&gt; _println_\(**"0 ..."**\)  
 **case** \_ =&gt; _println_\(**"something else"**\)  
 }

 **val** _tup_ = \(2, 3, 5\)  
 _tup_ **match** {  
 **case** \(2, x, y\) =&gt; _println_\(**s"1, $**x **, $**y**"**\)  
 **case** \(\_, z, 5\) =&gt; _println_\(z\)  
 **case** \_ =&gt; _println_\(**"else"**\)  
 }  
}

注意：在Scala中列表要么为空（Nil表示空列表）要么是一个head元素加上一个tail列表。

9 :: List\(5, 2\) :: 操作符是将给定的头和尾创建一个新的列表

注意：:: 操作符是右结合的，如9 :: 5 :: 2 :: Nil相当于 9 :: \(5 :: \(2 :: Nil\)\)

### 样例类

在Scala中样例类是一中特殊的类，可用于模式匹配。case class是多例的，后面要跟构造参数，case object是单例的

**import** scala.util.Random

  
__**case class** SubmitTask\(id: String, name: String\)  
**case class** HeartBeat\(time: Long\)  
**case object** CheckTimeOutTask

**object** CaseDemo04 **extends** App{  
 **val** _arr_ = _Array_\(CheckTimeOutTask, _HeartBeat_\(12333\), _SubmitTask_\(**"0001"**, **"task-0001"**\)\)

 _arr_\(Random.nextInt\(_arr_.length\)\) **match** {  
 **case** _SubmitTask_\(id, name\) =&gt; {  
 _println_\(**s"$**id**, $**name**"**\)  
 }  
 **case** _HeartBeat_\(time\) =&gt; {  
 _println_\(time\)  
 }  
 **case** CheckTimeOutTask =&gt; {  
 _println_\(**"check"**\)  
 }  
 }  
}

### Option类型

在Scala中Option类型样例类用来表示可能存在或也可能不存在的值\(Option的子类有Some和None\)。Some包装了某个值，None表示没有值

**object** OptionDemo {  
 **def** main\(args: Array\[String\]\) {  
 **val** map = _Map_\(**"a"** -&gt; 1, **"b"** -&gt; 2\)  
 **val** v = map.get\(**"b"**\) **match** {  
 **case** _Some_\(i\) =&gt; i  
 **case** None =&gt; 0  
 }  
 _println_\(v\)  
 _//更好的方式_  
 **val** v1 = map.getOrElse\(**"c"**, 0\)  
 _println_\(v1\)  
 }  
}

### 偏函数

被包在花括号内没有match的一组case语句是一个偏函数，它是PartialFunction\[A, B\]的一个实例，A代表参数类型，B代表返回类型，常用作输入模式匹配

**object** PartialFuncDemo {

 **def** func1: PartialFunction\[String, Int\] = {  
 **case "one"** =&gt; 1  
 **case "two"** =&gt; 2  
 **case** \_ =&gt; -1  
 }

  
 **def** func2\(num: String\) : Int = num **match** {  
 **case "one"** =&gt; 1  
 **case "two"** =&gt; 2  
 **case** \_ =&gt; -1  
 }

  
 **def** main\(args: Array\[String\]\) {  
 _println_\(_func1_\(**"one"**\)\)  
 _println_\(_func2_\(**"one"**\)\)  
 }  
}

